# Plugin Development

A plugin is a method of inserting code that runs before and after each
page's route code.

This document will explain how to develop a plugin; either for private
use with your own web site or to publicly share as a stand-alone library.

## the main, "route" and "after" procedures

When a `[varname] <- [pluginname](<params>)` pattern is seen after a `plugin`
the `jester` macro generates the following line of code before the the route
is called:

```nim
  var [varname] = [pluginname](request, result, <params>)
```

where,

    `request` is the current web request of type `Request`

and

    `result` is the  current response to the request of type `ResponseData`. 

See the `jester.nim` source code in the Jester library for more detail on those
types. The procedure can return any type it wishes as long as the type matches
corresponding "after" parameters. Since Nim automatically detects type when a
var statement is structured this way, the newly created variable automatically
has the correct type.

If, and only if, there is a `specific` instruction in the router then the macro
will generate a `if` statement checking for a prefix and insert that code.

The macro then generates the routes code underneath of a `routesList` block.

At the start of an individual route, just after any wild card parameters are
found in the matching url, the next routine is called:

```nim
  [pluginname]_route(request, result, [varname])
```

After the route's code is complete, then the following line of code is generated by the macro:

```nim
  [pluginname]_after(request, result, [varname])
```

All of the procedures can have the parameters made read-only or read-write (with
the `var` qualifier.)

The ``_route`` and and ``_after`` procedures are verified to exist before they
are called. If they do not exist, they are simply skipped without error. 

### Example

A short demo showing all of these effects, examine the following code:

```nim
import htmlgen
import jester
import strutils

type
  BunnyStr = string

proc haveBunny*(request: Request, response: ResponseData): BunnyStr =
  result = "Bunny"

# in this example, the haveBunny_route is skipped by simply not writing it.

proc haveBunny_after*(request: Request, response: ResponseData, b: BunnyStr) =
  if b.startsWith("Bugs"):
    echo "warning: page with possible trademark violation"

template notFast*(b: BunnyStr) =
  if request.pathInfo.contains("Fast"):
    result.action = TCActionSend
    result.code = Http303
    setHeader(result.headers, "Location", "/")
    result.content = ""
    result.matched = true
    result.completed = true  # this will cause the route code to be skipped

subrouter hutchRouter:
  specific:
    b.notFast()
  get "/@name":
    b = @"name" & " " & b
    resp h1("Hello Inside " & b)

routes:
  extend hutchRouter, "/hutch"
  plugin b <- haveBunny()
  get "/":
    resp h1("Hello " & b)
  get "/abc/@name":
    b = @"name" & " " & b
    resp h1("Hello " & b)
```

will end up generating code via macro:

```nim
proc match(request: Request): Future[ResponseData] {.async, gcsafe.} =
  block allRoutes:
    setDefaultResp()
    var request = request
    var b = haveBunny_before(request, result)
    block routesList:
    block routesList:
      if request.pathInfo.startsWith("/hutch"):
        b.notFast()
      if result.completed:
        break routesList
      case request.reqMethod
      of HttpGet:
        let patternMatchRet_580151 = match(@[
            Node(typ: NodeText, text: "/hutch", optional: false),
            Node(typ: NodeText, text: "/", optional: false),
            Node(typ: NodeField, text: "name", optional: false)], request.pathInfo)
        block outerRoute:
          if patternMatchRet_580151.matched:
            block route:
              when declared(haveBunny_route):
                haveBunny_route(request, result, b)
              setPatternParams(request, patternMatchRet_580151.params)
              b = @"name" & " " & b
              resp h1("Hello Inside " & b)
            if checkAction(result):
              result.matched = true
              break routesList
        block outerRoute:
          if request.pathInfo == "/":
            block route:
              when declared(haveBunny_route):
                haveBunny_route(request, result, b)
              resp h1("Hello " & b)
            if checkAction(result):
              result.matched = true
              break routesList
        let patternMatchRet_580159 = match(@[
            Node(typ: NodeText, text: "/abc/", optional: false),
            Node(typ: NodeField, text: "name", optional: false)], request.pathInfo)
        block outerRoute:
          if patternMatchRet_580159.matched:
            block route:
              setPatternParams(request, patternMatchRet_580159.params)
              when declared(haveBunny_route):
                haveBunny_route(request, result, b)
              b = @"name" & " " & b
              resp h1("Hello " & b)
            if checkAction(result):
              result.matched = true
              break routesList
      of HttpPost:
      of HttpPut:
      of HttpDelete:
      of HttpHead:
      of HttpOptions:
      of HttpTrace:
      of HttpConnect:
      of HttpPatch:
    block routesList:
    when declared(haveBunny_after):
      haveBunny_after(request, result, b)
```

## Playing Nice

A few "rules to live by" when writing a plugin library for the general public to use:

1. Plugins have an expectation that any "main", ``_plugin`` and ``_after`` code 
   will run. Please
   avoid writing a template or macro that returns from the generated `proc match`
   procedure. If you are wanting to avoid running the route code, such was when
   redirecting, set `results.completed = true` rather than returning.
2. The default is for `results.completed` to be `false`. So if your plugin sees
   it set to `true`, that means another plugin had a good reason to change that.
   Either leave it alone and let it remain `true`, or fully document in your plugin why
   you would reverse it back to `false`.
3. Most plugins will simply read the `request` parameter. If you are going to
   modify it, please fully document why, when, and what in your plugin's
   documentation.
4. Despite what you see in the previous example, refrain from using `echo` much,
   if at all. If each plugin regularly outputs debugging info to the terminal, 
   it can get quite noisy and messy.
5. When publishing to nimble, please include "jester" and "plugin" `tags` in
   the `packages.json` entry (in addition to other useful search tags.) This will
   make it easier for others to find your library.
