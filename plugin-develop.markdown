# Plugin Development

A plugin is a method of inserting code that runs before and after each
page's route code.

This document will explain how to develop a plugin; either for private
use with your own web site or to publicly share as a stand-alone library.

## the "before" and "after" procedures

When a `[varname] <- [pluginname](<params>)` pattern is seen after a `plugin`
the `jester` macro generates the following line of code before the the route
is called:

```nim
  var [varname] = [pluginname]_before(request, result, <params>)
```

where,

    `request` is the current web request of type `Request`

and

    `result` is the  current response to the request of type `ResponseData`. 

See the `jester.nim` source code in the Jester library for more detail on those
types. The procedure can return any type it wishes as long as the type matches
corresponding "after" parameters. Since Nim automatically detects type when a
var statement is structured this way, the newly created variable automatically
has the correct type.

If, and only if, there is a `specific` instruction in the router then the macro
will generate a `if` statement checking for a prefix and insert that code.

The macro then generates the routes code underneath of a `routesList` block.

After the route's code, then the following line of code is generated by the macro:

```nim
  [pluginname]_after(request, result, [varname])
```

Both the "before" and "after" procedures can have the parameter made read-only or
read-write (with the `var` qualifier.)

### Example

A short demo showing all of these effects, examine the following code:

```nim
import htmlgen
import jester
import strutils

type
  BunnyStr = string

proc haveBunny_before*(request: Request, response: ResponseData): BunnyStr =
  result = "Bunny"

proc haveBunny_after*(request: Request, response: ResponseData, b: BunnyStr) =
  if b.startsWith("Bugs"):
    echo "warning: page with possible trademark violation"

template notFast*(b: BunnyStr) =
  if request.pathInfo.contains("Fast"):
    result.action = TCActionSend
    result.code = Http303
    setHeader(result.headers, "Location", "/")
    result.content = ""
    result.matched = true  # this will cause the route code to be skipped

subrouter hutchRouter:
  specific:
    b.notFast()
  get "/@name":
    b = @"name" & " " & b
    resp h1("Hello Inside " & b)

routes:
  extend hutchRouter, "/hutch"
  plugin b <- haveBunny()
  get "/":
    resp h1("Hello " & b)
  get "/abc/@name":
    b = @"name" & " " & b
    resp h1("Hello " & b)
```

will end up generating code via macro:

```nim
proc match(request: Request): Future[ResponseData] {.async, gcsafe.} =
  block allRoutes:
    setDefaultResp()
    var request = request
    var b = haveBunny_before(request, result)
    block routesList:
    block routesList:
      if request.pathInfo.startsWith("/hutch"):
        b.notFast()
      if result.matched ==
          true:
        break routesList
      case request.reqMethod
      of HttpGet:
        let patternMatchRet_580151 = match(@[
            Node(typ: NodeText, text: "/hutch", optional: false),
            Node(typ: NodeText, text: "/", optional: false),
            Node(typ: NodeField, text: "name", optional: false)], request.pathInfo)
        block outerRoute:
          if patternMatchRet_580151.matched:
            block route:
              setPatternParams(request, patternMatchRet_580151.params)
              b = @"name" & " " & b
              resp h1("Hello Inside " & b)
            if checkAction(result):
              result.matched = true
              break routesList
        block outerRoute:
          if request.pathInfo == "/":
            block route:
              resp h1("Hello " & b)
            if checkAction(result):
              result.matched = true
              break routesList
        let patternMatchRet_580173 = match(@[
            Node(typ: NodeText, text: "/abc/", optional: false),
            Node(typ: NodeField, text: "name", optional: false)], request.pathInfo)
        block outerRoute:
          if patternMatchRet_580173.matched:
            block route:
              setPatternParams(request, patternMatchRet_580173.params)
              b = @"name" & " " & b
              resp h1("Hello " & b)
            if checkAction(result):
              result.matched = true
              break routesList
      of HttpPost:
      of HttpPut:
      of HttpDelete:
      of HttpHead:
      of HttpOptions:
      of HttpTrace:
      of HttpConnect:
      of HttpPatch:
    block routesList:
    haveBunny_after(request, result, b)
```

## Playing Nice

A few "rules to live by" when writing a plugin library for the general public to use:

1. Plugins have an expectation that *both* the "before" and "after" code will run. Please
   avoid writing a template or macro that returns from the generated `proc match`
   procedure. If you are wanting to avoid running the route code, such was when
   redirecting, set `results.matched = true` rather than returning.
2. The default is for `results.matched` to be `false`. So if your plugin sees
   it set to `true`, that means another plugin had a good reason to do that.
   Either leave it alone and remain `true` or fully document in your plugin why
   you would reverse it back to `false`.
3. Most plugins will simply read the `request` parameter. If you are going to
   modify it, please fully document why, when, and what in your plugin's
   documentation.
4. Despite what you see in the previous example, refrain from using `echo` much,
   if at all. If each plugin regularly outputs debugging info to the terminal, 
   it can get quite noisy and messy.
5. When publishing to nimble, please include "jester" and "plugin" `tags` in
   the `packages.json` entry (in addition to other useful search tags.) This will
   make it easier for others to find your library.
